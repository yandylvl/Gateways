import axios from "axios";
import MockAdapter from "axios-mock-adapter";

import {
  addGateway,
  deleteGateway,
  editGateway,
  getGatewaysByPeripheralsCount,
  loadGateways,
} from "../store/modules/entities/gateways";
import configStore from "../store/configureStore";

describe("gatewaysSlice", () => {
  let fakeAxios;
  let store;

  beforeEach(() => {
    fakeAxios = new MockAdapter(axios);
    store = configStore();
  });

  const gatewaysSlice = () => store.getState().entities.gateways;

  const createState = () => ({
    entities: {
      gateways: {
        list: [],
      },
    },
  });

  describe("loading gateways", () => {
    it("should be fetched from the server and put in the store", async () => {
      fakeAxios.onGet("/gateways").reply(200, [{ id: 1 }]);

      await store.dispatch(loadGateways());

      expect(gatewaysSlice().list).toHaveLength(1);
    });

    describe("loading indicator", () => {
      it("should be true while fetcihng the gateways", () => {
        fakeAxios.onGet("/gateways").reply(() => {
          expect(gatewaysSlice().loading).toBe(true);
          return [200, [{ id: 1 }]];
        });

        store.dispatch(loadGateways());
      });

      it("should be false after the gateways are fetched", async () => {
        fakeAxios.onGet("/gateways").reply(200, [{ id: 1 }]);

        await store.dispatch(loadGateways());

        expect(gatewaysSlice().loading).toBe(false);
      });

      it("should be false if the server return an error", async () => {
        fakeAxios.onGet("/gateways").reply(500);

        await store.dispatch(loadGateways());

        expect(gatewaysSlice().loading).toBe(false);
      });
    });
  });

  it("should add the gateway to the store if it's saved to the server", async () => {
    const gateway = { serialNumber: "a" };
    const savedGateway = { ...gateway, id: 1 };
    fakeAxios.onPost("/gateways").reply(200, savedGateway);

    await store.dispatch(addGateway(gateway));

    expect(gatewaysSlice().list).toContainEqual(savedGateway);
  });

  it("should not add the gateway to the store if it's not saved to the server", async () => {
    const gateway = { serialNumber: "a" };
    fakeAxios.onPost("/gateways").reply(500);

    await store.dispatch(addGateway(gateway));

    expect(gatewaysSlice().list).toHaveLength(0);
  });

  it("should edit the gateway in the store if it's edited in the server", async () => {
    const gateway = { id: 1, name: "a" };
    const editedGateway = { ...gateway, name: "b" };
    fakeAxios.onPost("/gateways").reply(200, { id: 1 });
    fakeAxios.onPut("/gateways/1").reply(200, editedGateway);

    await store.dispatch(addGateway({}));
    await store.dispatch(editGateway({ id: 1 }));

    expect(gatewaysSlice().list[0].name).toEqual("b");
  });

  //TODO: test !edited in the server

  it("should delete the gateway from the store if it's deleted from the server", async () => {
    fakeAxios.onPost("/gateways").reply(200, { id: 1 });
    fakeAxios.onDelete("/gateways/1").reply(200, { id: 1 });

    await store.dispatch(addGateway({}));
    await store.dispatch(deleteGateway(1));

    expect(gatewaysSlice().list).toHaveLength(0);
  });

  //TODO: test !deleted from the server

  describe("selectors", () => {
    //TODO: create more data tests using manual mocks (__mocks__) or autogenerated
    describe("getGatewaysByPeripheralsCount", () => {
      it("should filter gateways by peripherals", () => {
        const state = createState();
        state.entities.gateways.list = [
          { peripherals: [1, 2, 3] },
          { peripherals: [1, 2, 3] },
          { peripherals: [3] },
          { peripherals: [1] },
          { peripherals: [2] },
          { peripherals: [] },
        ];

        const result = getGatewaysByPeripheralsCount(1)(state);

        expect(result).toHaveLength(3);
      });

      it("should return entire list if no filter is passed", () => {
        const state = createState();
        state.entities.gateways.list = [
          { peripherals: [1, 2, 3] },
          { peripherals: [1, 2, 3] },
          { peripherals: [3] },
          { peripherals: [1] },
          { peripherals: [2] },
          { peripherals: [] },
        ];

        const result = getGatewaysByPeripheralsCount()(state);

        expect(result).toHaveLength(0);
      });
    });
  });
});
